---
layout:     post
title:      "Java Learning Tutorials Chapter 1"
subtitle:   " \"Hello World, Hello Blog\""
date:       2016-11-17 18：00
author:     "Leonard Yuan"
header-img: "img/home-bg-art.jpg"
catalog: true
tags:
    - Java

---

>java学习笔记。

---

# java学习笔记


## 1.编写Java程序时，应注意以下几点：

a.大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。

b.类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。

c.方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。

d.源文件名： 源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。可以将一个类的声明放在一个单独的文件中，也**可以将多个类的声明放在一个文件中（在这种情况下，最多只能有一个类声明为公有类）**。命名已公有类为准。

e.主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。

## 2.Java标识符的注意事项：


- 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始

- 首字符之后可以是任何字符的组合

- 关键字不能用作标识符

- 标识符是大小写敏感的

- 非法标识符举例：123abc、-salary

## 3.java中的类

### (1).类中变量类型

- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。

- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。

- **类变量**：类变量也声明在类中，方法体之外，但必须声明为`static`类型。

### (2).构造方法

和C++中类的构造方法的构成一致。当创建类的时候，会提供一个和类同名的函数，名为构造方法。当在创建类的时候不创建构造方法时，系统会自动生成隐含构造方法。可以创建不止一个构造方法；例子如下：

	public class Puppy{
   		public Puppy(){
   		}
   		public Puppy(String name){
      // 这个构造器仅有一个参数：name
   		}
	}
构造方法可以被重载；

### (3).类中数据成员

#### a.格式说明

	public、protected、private 为访问控制符
	static指明这是一个静态成员变量
	final指明变量的值不能被修改
	transient指明变量是临时状态
	volatile指明变量是一个共享变量
对于静态变量static，可以直接对类中的值进行修改，如;

变量类型和C++的基本一致，略；

没有static修饰的变量（属性）称为实例变量(Instance Variables)；
当一个对象被创建时 会对其中各种类型的 成员变量自动进行初 始化赋值

#### b.变量的初始化

变量的初始化可以在两个地方：

	1.在final变量定义时直接给其赋值。
	2.在构造方法中赋值。
	这两个地方只能选其一，不能同时既在定义时 给了值，又在构造方法中给另外的值。 final实例变量可在1或2中初始化 final类变量必须在1中初始化。
类变量的：又称静态变量，声明时需在前边加`static`修饰符；

实例变量：在类中定义的普通变量。

#### c.方法的构建和调用

调用和构建的方法和c++的没有多大的区别。定义的方法为：

	<返回类型><方法名><参数传递>
前边也可以加public、protect等进行访问限制。

参数传递的方法：

	值传递：参数类型为基本数据类型；
	引用传递：参数类型为对象类型或数组；
方法分为两类，一种为**类方法**，另外一种为**实例方法**。 其中类方法必须在在类声明前面加`static`，并且类方法可以在建立对象的情况下利用类名直接调用，也可以通过类实例来调用。

#### d.类中引用包的方法

在类中要引用包时，使用的格式为：

	import package1[.package2…]. (classname |*);
如果要引用包中的所有类时，在（classname）用`*`来代替。实例如下：

	import  java.io.*; //引用了包中所有的类
	 import java.io.FileWriter; //引用了包中的一个类

#### e.类的访问控制

对类的访问控制通过在类前面加修饰符`public`来实现。当类前面有`piblic`时，表示所有其他的类都可以访问这个类。如果类前面无修饰符（缺省类）时，该泪只能被在同一个包中的类引用。

#### f.类成员的访问控制

对于类的访问时，使用public、private、protect、default修饰符来实现控制控制，具体略。

对于类中的变量，可以修饰其为`private`，防止被非法访问。当需要访问或者修改时，可以设置开头为“get-”和“set-”的函数，用于访问和修改。

当方法中的形参和实例变量名同名时，使用`this.`进行区别。如下：

	public void setRadius(int radius){   
		this.radius = radius;
	}

#### g.对象的初始化和回收

对象的初始化使用构造方法就可以实现。当类中没有构造方法时，系统会默认生成一个默认构造方法。当有构造方法时，就不产生默认构造方法了。在引用构造方法时，可以使用`this`关键词来实现。

**使用默认的构造方法初始化对象时，如果 在类声明中没有给实例变量赋初值，则对象的属性值为零或空（null）**

#### h.内存回收技术

使用finalize()方法，finalize()方法不需要显示地调用， 在垃圾回收(GC)时会被自动先行调用的。finalize()方法在如下三种情况下会被调用：

	1.所有对象被Garbage Collection时自动调用,比如运行System.gc()的时候；
	2.程序退出时为每个对象调用一次finalize方法；
	3.显式的调用finalize方法；

#### i.声明tostring()方法

用于将类中的内容转换为字符串，在类中会默认有tostring()的方法。如果有需要的话，需要对tostring()进行重写重写必须符合如下的条件：

	1.必须被声明为public；
	2.返回类型为String；
	3.方法的名称必须为toString，且没有参数；
	4，在方法体中不要使用输出方法 System.out.println()；

## 4.类的方法

## (1).方法的控制流程

	选择结构：
	if语句（二路选择结构）
	switch语句（多路选择结构）
	<switch结构的中的值需时整数或者字符型>

	循环结构：
	for语句
	while语句   <该结构的循环体至少被执行一次>
	do-while语句
`break`的用法：

用于跳出break所在的那个循环，如下程序：

	for ( i = 1; i <= 10; i++ ) {
      	     if ( i == 5 )    
				break; // break loop only if count == 5
      	     output += i + " ";
        }
`break`经常与`label`搭配使用，其中label是用于标记哪一个循环的，跳出标号标识的循环结构。这样在特定的条件下可以跳出特定的循环，具体的程序如下：

	outer:
		for (int i=1; i<=9;i++) {
          for (int j=1; j<=9;j++){
               if (j > i)   break;
               if (i==6)  break outer;          
               System.out.print("  "+i+"*"+j+"="+i*j);
            }
            System.out.println();
	   }
	表示当j>i时跳出j的循环，当i=6时，跳出i所在的循环，从而打印出5*5的乘法表。
`continue`的用法：

作用：用于循环结构中，停止本次迭代，回到循环起始处，开始下一次迭代过程。其用法有不带标号和带标号两种，不带标号的和以前一样，略。带标号的，示例程序如下：

	outer: 	  
	for (int i=1; i<10; i++){
		inner:
		for (int j=1; j<10; j++){
			if (i<j){
 				System.out.println();                         
				continue outer;
		} 	                
		System.out.print("  "+i+"*"+j+"="+i*j);
	} 	     
	当continue outer时，跳到i所在循环，执行下一次迭代。

## (2).异常处理

异常处理的方法与python中的异常处理的方式比较相同，示例程序如下：

	try {
	    //Perform a task  
	    result = number1 / number2;
	    //Perform next task
	}
	catch (ArithmeticException e) { //如果产生算数类异常

	      //处理异常
	}
	catch (Exception e) { //如果产生其他异常

	      //处理异常
	}
异常的基本概念：

每当Java程序运行过程中发生一个可识别的运行错误时，即该错误有一个异常类与之相对应时，系统都会**产生一个相应的该异常类的对象**， 即产生一个异常。异常分为检查型异常和非检查型异常。对于检查型异常处理的方法一共有两种，一种把异常直接抛出到调用方法之外，这种方法对于程序设计不严谨；另一种方法是使用try{}catch{}来捕获异常，并对异常进行处理。

Java中错误的基本概念：（在java中错误一共分为两种，一种为错误，另外一种为异常）

	错误：
		1.致命性的，用户程序无法处理；
		2.Error类是所有错误类的父类；

	异常：
		非致命性的，可编制程序捕获和处理；
		Exception类是所有异常类的父类；

在java中使用try{}catch{}语句对异常进行处理，处理方法如下：

	try子句：
	1.其后跟随可能产生异常的代码块；
	2.产生异常后，位于try内的产生异常的代码块之后的代码不会再运行

	catch子句：
	1.其后跟随异常处理语句，通常用到两个方法：
		getMessage() – 返回一个字符串对发生的异常进行描述；
	    printStackTrace() – 给出方法的调用序列，一直到异常的 产生位置 ，通常在测试和调试时有用；
	2.在异常发生时，程序将查找第1个能处理异常的catch子句：抛出的异常类型和异常参数类型相同或者是后者的子类；
	3.catch子句处理完毕后，程序将忽略任何与try块相关的其他子句，并从try/catch后的第1行代码开始运行。

	finally子句：
	1.不论在try代码段是否产生异常，finally子句的程序代码段都会被执行。通常在这里释放相应的try块所获取的内存以外的其他资源；
	2.如果使用return、break或continue语句退出try块，java也将保证执行finally子句,然后再 回到return、break或continue 。3.finally子句执行后，程序控制将从finally子句后的第1条语句开始执行。
	~~~~finally中程序无论如何都是要被执行的；

生成异常处理--------------PPT中有。

**重点：声明自己的异常类：**

除使用系统预定义的异常类外，用户还可声明自己的异常类。注：自定义的所有异常类都必须是Exception的子类。其一般声明如下：

	public  class MyExceptionName extends SuperclassOfMyException{
		public MyExceptionName(){
			super("Some string explaining the exception");
		 }
	}

## 5.方法的重载

在类中，类的重载的方法与类中构造函数的重载方法相同，都是通过方法参数中的参数个数，参数类型来进行区别。具体构造代码略。
